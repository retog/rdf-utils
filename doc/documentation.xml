<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<article>
  <title>RDF – Molecules for leanification and diffs</title>

  <section>
    <title>Introduction</title>

    <para>The concept of "RDF Molecules"<footnote>
        <para>L. Ding, T. Finin, Y. Peng, P. Pinheiro da Silva, D. L.
        McGuinness, 2005, <ulink
        url="http://www.ksl.stanford.edu/people/pp/papers/Ding_ISWC_2005.pdf">http://www.ksl.stanford.edu/people/pp/papers/Ding_ISWC_2005.pdf</ulink></para>
      </footnote>is not only useful for tracking RDF Graph Provenance but also
    to efficiently detect subgraphs and find minimal isomorphic graphs i.e.
    removing duplicate anonymous nodes as well as to allow diffs between
    rdf-graphs.</para>

    <section>
      <title>Leanify (minimal isomorphic graph)</title>

      <para>In Jena anonymous nodes are represented by Resource-Objects
      created using the method Model.createResource(). The resource becomes a
      node of the graph as soon as it is used in a statement.</para>

      <programlisting>...
Model model = ModelFactory.createDefaultModel();
Resource anonRes = model.createResource();
anonRes.addProperty(RDFS.label, "A node");
Resource anonRes2 = model.createResource();
anonRes2.addProperty(RDFS.label, "A node");
</programlisting>

      <para>This code creates two anonymous Resource-Object in Jena while it
      creates only one distinct anonymous RDF-Node. The Jena serialization of
      the model, generated by calling:</para>

      <programlisting>model.write(System.out);</programlisting>

      <para>is the following RDF/XML</para>

      <programlisting>&lt;rdf:RDF
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" &gt;
  &lt;rdf:Description rdf:nodeID="A0"&gt;
    &lt;rdfs:label&gt;A node&lt;/rdfs:label&gt;
  &lt;/rdf:Description&gt;
  &lt;rdf:Description rdf:nodeID="A1"&gt;
    &lt;rdfs:label&gt;A node&lt;/rdfs:label&gt;
  &lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;
</programlisting>

      <para>The serialization looks as if the graph would contain two nodes,
      while in fact these are identical i.e. only one node.</para>

      <para>However for the Jena-API it makes sense to keep the two resources
      as subsequent API-calls may in fact make the two Java-Object dinsting
      nodes in the the graph.</para>

      <programlisting>anonRes.addProperty(RDFS.comment,"A person met yesterday");
anonRes2.addProperty(RDFS.comment,"A person met today");</programlisting>

      <para>After this calls the <varname>anonRes</varname> and
      <varname>anonRes2</varname>are two different resource and the graph
      contains two anonymous nodes in terms of RDF, this shows that keeping
      duplicate resource is not a bug but intrinsincally needed by the design
      of the Jena-API. However is is useful to<itemizedlist>
          <listitem>
            <para>Remove duplicate resource on an existing model</para>
          </listitem>

          <listitem>
            <para>Merge models without producing duplicate resource</para>
          </listitem>
        </itemizedlist>While these tasks may require massive calculation in
      the general case and thus be very slow (an NP complete probelm), things
      get faster when identities implied by functional and inverse-functional
      property are considered as well. In terms of RDF-Modecules this means
      <itemizedlist>
          <listitem>
            <para>Remove duplicates resources in contextual molecules</para>
          </listitem>

          <listitem>
            <para>Remove duplicate molecules</para>
          </listitem>

          <listitem>
            <para>Remove contextual molecules which a subgraph of another
            contextual molecule</para>
          </listitem>
        </itemizedlist><note>
          <para>This procedure does not take into account, that a contextaul
          molecule (and it's anonymous nodes) can be made obsolete by terminal
          molecules or by a union of terminal and contextual molecules. To
          remove all redundant statements each contextual molecule should be
          checked if it is a subgraph of the union of all other molecules. Not
          sure how this could be done with reasonable
          efficience.<programlisting>In the molecule:

_:a eg:prop1 _:b
_:b eg:prop2 eg:res

_:a is same as _:a1 in

_:a1 eg:prop1 eg:res1 (a contextual molecule)
if eg:res1 eg:prop2 eg:res (a terminal molecule)
</programlisting></para>
        </note></para>
    </section>

    <section>
      <title>Diff</title>

      <para>As Ding et all suggest rdf-molecules are the right granularity for
      rdf-diff. At this level a diff is independent of the serialization and
      of the labels of anonymous nodes. The basic idea is to split two models
      into molecules, remove the molecules present in both et voilà!</para>

      <para>However a few issuses need to be considered:</para>

      <itemizedlist>
        <listitem>
          <para>While nt-molecules present in other molecules need not to be
          kept, the other are relevant</para>
        </listitem>

        <listitem>
          <para>If a node is functionally grounded by multiple nt-molecules it
          is un defined which nt-molecule is used to ground the node in
          terminal and contextual molecules</para>
        </listitem>
      </itemizedlist>

      <para>The solution implemented introduces the notion of
      <emphasis>reference grounded nodes</emphasis>, where the fg-nodes are
      treated as reference to all their grounding nt-molecules. The way this
      is serialized in a diff is discussed below.</para>
    </section>
  </section>

  <section>
    <title>Implementing Model Decomposition</title>

    <section>
      <title>Base infrastructure</title>

      <para>Some molecule independent interfaces <classname>Graph</classname>,
      <classname>Triple</classname>, <classname>Node</classname> and
      <classname>GroundedNode </classname>are introduced. A Graph is a sublass
      of <classname>java.utilCollection&lt;Triple&gt;</classname>, the
      difference to a <classname>java.util.Set&lt;Triple&gt;</classname> is a
      different identity criterion, two <classname>Graph</classname>s are
      equal iff they represent isomorphic graphs, only the
      <classname>GroundedNode</classname>s need to be equal according to their
      <methodname>equals</methodname> methods, other nodes must be present at
      corresponding postions withing the two <classname>Graph</classname>s.
      This special infrastructure was needed also because when creating and
      dealing with molecules other kind of grounded nodes than those in rdf
      (called <emphasis>naturally grounded node</emphasis> by Diff et all)
      will be used, specifically in model-referencing decomposition anonymous
      nodes are considered as grounded and in nt-referencing decompostion
      functionally grounded anonymous nodes are represented by instances of
      <classname>GroundedNode</classname>.</para>
    </section>

    <section>
      <title>Steps to create Molecules</title>

      <para>In the creation of molecules from a model is done through
      intermediate steps. The first step creates Modelcules that do not fully
      describe the anonymous nodes they contain, the anonymous resources in
      these <glossterm baseform="reductive molecule">reductive
      molecules</glossterm> reference to their position in the original Model.
      The second step creates Molecules in which nodes wich are functionally
      grounded in the model are not grounded but reference
      <emphasis>all</emphasis> non-terminal molecules which would ground the
      node. In the third step the references two non-terminal molecules are
      dereferenced (using an arbitrary non-terminal molecule referenced by the
      functionally grounded node) and thus <glossterm
      baseform="reductive molecule">non-reductive molecules</glossterm> are
      created.</para>

      <section>
        <title>Model-Referencing Decomposition</title>

        <para>This involves a maximal (non-loosles) decomposition of the model
        and the creation of all non-terminal molecules</para>

        <section>
          <title>Maximal Decomposition</title>

          <para>For every statement in the model a molecule is created and it
          is determined of which of the following types it belongs, note that
          it is not necessary in this step to determine if a molecule is
          reductive or non-reductive:</para>

          <itemizedlist>
            <listitem>
              <para>Terminal Molecule</para>

              <para>Are created from Statements which do not contain any
              anonymous node, i.e. every node is naturally grounded. This
              molecules are non-reductive</para>
            </listitem>

            <listitem>
              <para>Non-Terminal Molecules</para>

              <para>Are created from statements with a functional or
              inverse-functional property and only one anonymous node. This
              molecules are non-reductive if the anonymous node is not present
              in any other statement of the model otherwise they are
              reductive.</para>
            </listitem>

            <listitem>
              <para>Non-Terminal-Part-Candidate Molecules</para>

              <para>Are created from statements with a functional or inverse
              functional property and two anonymous nodes.</para>
            </listitem>

            <listitem>
              <para>Contextual Molecules</para>

              <para>Are created from statements which contain at least one
              anonymous node but do not have a functional or
              inverse-functional property.</para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>Creation of Non-Terminal-Molecules</title>

          <para>In this step new Non-Terminal Molecules are created using the
          Non-Terminal-Part-Candidate Molecules and exitsting Terminal
          Molecules, as a result every Non-Terminal-Part-Candidate Molecule
          becomes part of of a Non-Terminal or a Contextual Molecule.</para>
        </section>
      </section>

      <section>
        <title>NT-Referencing Decomposition</title>

        <para>The scope of this step is to make all reference to the original
        graph obsolete without creating functionally grounded molecules in a
        non-deterministic way.</para>

        <section>
          <title>Creating functionally grounded nodes</title>

          <para>Non-Terminal Molecules which share the same afgn are detected
          and a functionlly gronded node fgn is created. A fgn is a
          java-object referencing implementing
          <classname>GroundedNode</classname> to all the grounding
          nt-molecules.</para>
        </section>

        <section>
          <title>Determining active-functionally grounded Nodes in contextual
          Molecules</title>

          <para>The existing set of molecules is processed so that used but
          not grounded nodes are replaced with a reference to all non-terminal
          molecules of which they are the active-functionally-grounded node,
          the molecules resulting from this opperation may be terminable
          molecules, this is when the result of the union with any
          non-terminal-molecule referenced results in a terminal molecule or
          contextual molecules.</para>
        </section>

        <section>
          <title>Creating Maximum Contextual Molecules</title>

          <para>Merge all Contextual Molecules which share a node which is
          neither naturally grounded nor a reference to non-terminal
          molecules</para>
        </section>
      </section>

      <section>
        <title>Self-contained decompostion</title>

        <para>Creates molecules as proposed by Ding et All.</para>
      </section>
    </section>

    <section>
      <title>Test-Cases</title>

      <para>This section describes the testcases derived from Ding et all's
      introduction of RDF Molecules.</para>

      <section>
        <title>Splitting with empty Ontology</title>

        <para>TODO</para>
      </section>
    </section>
  </section>

  <section>
    <title>Leanify</title>

    <para>TODO</para>
  </section>

  <section>
    <title>Diff</title>

    <para>TODO</para>

    <section>
      <title>Serialization</title>

      <para>The goal is to introduce the least possible amount of conventions
      and syntactic constructs while keeping the size of the diff
      minimal.</para>

      <para>The individual molecules are serialzed as RDF/XML, all the
      nt-molecules grounding the same fg-node are also serialized as
      RDF/XML.</para>

      <para>-&gt; reference through special ifp (subclass of
      isPrimaryTopicOf)</para>

      <para>-&gt; dirs: onlyIn1/onlyIn2 and
      used-common-fg-nodes/fg-nodes-only-in-1/fg-nodes-only-in-2/cg-fg-nodes</para>

      <para>-&gt; for 1-1 cg-fg-nodes the directory is referenced, otherwise
      the concrete file.</para>

      <para>cg-fg-node: (a-b), (c-d) / (b-c) can have no reference nowehere
      -&gt; keep all cg-fg-nodes</para>
    </section>
  </section>
</article>